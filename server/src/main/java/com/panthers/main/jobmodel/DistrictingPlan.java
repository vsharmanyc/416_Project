package com.panthers.main.jobmodel;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.panthers.main.mapmodel.District;
import com.panthers.main.mapmodel.States;

import java.util.*;

/**
 * One districting plan of many generated by the algorithm. Holds resultant districtings, and job information for that
 * district
 */
public class DistrictingPlan {
    @JsonIgnore
    private States state;
    private int districtingPlanID;
    private List<District> districts;
    @JsonIgnore
    private List<List<District>> districtGraph;
    @JsonIgnore
    private CompactnessMeasure compactnessMeasure;
    @JsonIgnore
    private double popEqThreshold;
    @JsonIgnore
    private String compactnessRequested;
    @JsonIgnore
    private DistrictingType type;
    @JsonIgnore
    private int counties;
    @JsonIgnore
    private double deviationFromAverage;// Utilized in the 'determine x districting' functions

    public DistrictingPlan(States state, List<District> districts,
                           double popEqThreshold, String compactnessRequested) {
        this.state = state;
        this.districts = districts;
        this.popEqThreshold = popEqThreshold;
        this.compactnessRequested = compactnessRequested;
        this.type = null;
        this.counties = -1;
        this.districtGraph = new ArrayList<>();
        this.deviationFromAverage = 0.0;
        this.districtingPlanID = -1;
    }

    public int getDistrictingPlanID() {
        return districtingPlanID;
    }

    public void setDistrictingPlanID(int districtingPlanID) {
        this.districtingPlanID = districtingPlanID;
    }

    public double getDeviationFromAverage() {
        return deviationFromAverage;
    }

    public void setDeviationFromAverage(double deviationFromAverage) {
        this.deviationFromAverage = deviationFromAverage;
    }
    /* GETTERS/SETTERS */

    public States getState() {
        return state;
    }

    public void setState(States state) {
        this.state = state;
    }

    public List<District> getDistricts() {
        return districts;
    }

    public void setDistricts(List<District> districts) {
        this.districts = districts;
    }

    public CompactnessMeasure getCompactnessMeasure() {
        return compactnessMeasure;
    }

    public void setCompactnessMeasure(CompactnessMeasure compactnessMeasure) {
        this.compactnessMeasure = compactnessMeasure;
    }

    public double getPopEqThreshold() {
        return popEqThreshold;
    }

    public void setPopEqThreshold(double popEqThreshold) {
        this.popEqThreshold = popEqThreshold;
    }

    public String getCompactnessRequested() {
        return compactnessRequested;
    }

    public void setCompactnessRequested(String compactnessRequested) {
        this.compactnessRequested = compactnessRequested;
    }

    public DistrictingType getType() {
        return type;
    }

    public void setType(DistrictingType type) {
        this.type = type;
    }

    public int getCounties() {
        return counties;
    }

    public void setCounties(int counties) {
        this.counties = counties;
    }

    public String toString(){
        return "Districts:" + districts + ",\nPopEqThreshold: " + popEqThreshold + ",\nCompactness: "  + compactnessRequested
                + ",\nType: " + type + "\n\n";
    }

    /* FUNCTIONS */

    /**
     * Sorts the districts in this districting plan by the mvapPercentage. Utilizes the collections.sort functionality,
     * since District implements Comparable
     */
    public void sortDistrictsByMVAP(){
        Collections.sort(districts);
    }

    /**
     * function generates a district graph for this districting; for use in generating a run results Summary file.
     * @return returns the resultant districting graph, stores in an adjacency list.
     */
    public List<List<District>> generateDistrictGraph(){
        return null;
    }

    /**
     * Adds the district to the districting graph. Includes neighbors for storage in adjacency list.
     * @param d district were adding
     * @param neighbors connections to that district in the overall districting graph.
     */
    public void addToDistrictGraph(District d, List<District> neighbors){

    }

    /**
     * function returns the nth district contained in this districting list.
     * @param n the index of district the function is to return
     * @return returns that nth districting if n is within bounds of districts, else returns null
     */
    public District getNthDistrict(int n){
        if (n < 0 || n >= districts.size())
            return null;
        return districts.get(n);
    }

    /**
     * LOOSE DEFINITION:
     * function is to calculate this districtings association with the implemented districting plan.
     */
    public void calculateDistrictingAssociation(){

    }
}
